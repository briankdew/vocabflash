<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>vocabflash™</title>
  <link rel="icon" type="image/png" href="vocabflash favicon.png">

  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500&family=Nunito:wght@400;700&family=Archivo:wght@400;600;700&family=Libre+Baskerville:ital@1&display=swap" rel="stylesheet">

  <style>
    :root{
      /* --- PALETTE DEFINITIONS (OKLCH) --- */
      
      /* Neutrals */
      --color-white: #ffffff;

      /* Backgrounds */
      --palette-bg: oklch(0.96 0.015 101);       /* #f4f2e7 */

      /* Beige Scale */
      --palette-beige-00: oklch(0.92 0.0159 101); /* #e7e5d9 */
      --palette-beige-01: oklch(0.88 0.0168 101); /* #dad8cc */
      --palette-beige-02: oklch(0.8 0.0186 101);  /* #c0beb1 */
      --palette-beige-03: oklch(0.72 0.0204 101); /* #a7a597 */
      --palette-beige-04: oklch(0.64 0.0222 101); /* #8f8d7e */
      --palette-beige-05: oklch(0.56 0.024 101);  /* #777565 */
      --palette-beige-06: oklch(0.48 0.0258 101); /* #615e4e */
      --palette-beige-07: oklch(0.4 0.0276 101);  /* #4b4837 */
      --palette-beige-08: oklch(0.32 0.0294 101); /* #363322 */
      --palette-beige-09: oklch(0.24 0.0312 101); /* #22200e */
      --palette-beige-10: oklch(0.16 0.033 101);  /* #100d00 */

      /* Green Scale */
      --palette-green-00: oklch(0.96 0.0197 136.6); /* ecf5e8 */
      --palette-green-01: oklch(0.88 0.0354 136.6); /* cdddc6 */
      --palette-green-02: oklch(0.80 0.0510 136.6); /* afc6a6 */
      --palette-green-03: oklch(0.718 0.0667 136.6); /* 91ae85 */
      --palette-green-04: oklch(0.64 0.0700 136.6); /* 79966c */
      --palette-green-05: oklch(0.56 0.0733 136.6); /* 607f53 */
      --palette-green-06: oklch(0.48 0.0767 136.6); /* 49683b */
      --palette-green-07: oklch(0.40 0.0800 136.6); /* 325124 */
      --palette-green-08: oklch(0.32 0.0833 136.6); /* 1d3c0b */
      --palette-green-09: oklch(0.24 0.0867 136.6); /* 072700 */
      --palette-green-10: oklch(0.16 0.0900 136.6); /* 001300 */

      /* Red Scale */
      --palette-red-00: oklch(0.9600 0.0156 18.00); /* #ffeded */
      --palette-red-01: oklch(0.9200 0.0313 18.00); /* #ffdada */
      --palette-red-02: oklch(0.8800 0.0625 18.00); /* #fec8c8 */
      --palette-red-03: oklch(0.8000 0.1094 18.00); /* #faa2a4 */
      --palette-red-04: oklch(0.7200 0.1719 18.00); /* #f27b81 */
      --palette-red-05: oklch(0.6400 0.2031 18.00); /* #e84e5f */
      --palette-red-06: oklch(0.5600 0.2109 18.00); /* #d8013f */
      --palette-red-07: oklch(0.4800 0.1875 18.00); /* #b00131 */
      --palette-red-08: oklch(0.4000 0.1563 18.00); /* #890124 */
      --palette-red-19: oklch(0.3200 0.1250 18.00); /* #640018 */
      --palette-red-10: oklch(0.2400 0.0938 18.00); /* #42000d */
      
      --theme-logo-vocab: var(--palette-beige-05);
      --theme-logo-flash: var(--palette-beige-08);
      --theme-tagline: var(--palette-beige-05);
      
      --card: var(--color-white);
      --text: var(--palette-beige-09);
      --radius:20px;
      --gap:1rem;
    }
    *{ box-sizing:border-box; }
    header {
      text-align: center;
      margin: 1rem 0;
    }
    
    .logo {
      font-family: 'Fredoka', sans-serif;
      font-size: clamp(40px, 10vw, 80px);
      font-weight: 500;
      line-height: 1;
    }
    
    .logo-vocab { color: var(--theme-logo-vocab) !important; forced-color-adjust: none; }
    .logo-flash { color: var(--theme-logo-flash) !important; forced-color-adjust: none; }
    
    .tagline {
      font-family: 'Fredoka', sans-serif;
      font-size: clamp(16px, 3vw, 24px);
      font-weight: 400;
      color: var(--theme-tagline) !important;
      margin-top: 0.25rem;
      forced-color-adjust: none;
}

    body{
      margin:0;
      font-family: 'Archivo', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: var(--palette-bg);
      color: var(--text);
    }
    .wrap{
      max-width: 720px;
      margin: 0 auto;
      padding: 18px 14px 28px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: var(--gap);
    }
    .flashcard{
      width: min(640px, 100%);
      background: var(--card);
      border-radius: var(--radius);
      padding: 22px 18px;
      min-height: clamp(260px, 36vh, 420px);
      box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.5);
      text-align:center;
    }
    .front-affix{
      font-weight: 800;
      font-size: clamp(34px, 10vw, 64px);
      line-height: 1.1;
      letter-spacing: 0.2px;
      margin: 8px 0;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .back-affix, .qa-question{
      font-weight: 800;
      font-size: clamp(28px, 6vw, 42px);
      line-height: 1.15;
      margin: 0 0 10px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .meaning{
      font-size: clamp(18px, 3.8vw, 22px);
      line-height: 1.35;
      margin: 6px 0 18px;
    }
    .cheatline{
      font-size: clamp(16px, 3.4vw, 20px);
      line-height: 1.35;
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .below{
      width: min(640px, 100%);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: var(--gap);
    }
    .cheatword{
      width: 100%;
      background: var(--card);
      border-radius: var(--radius);
      padding: 12px 14px;
      text-align:center;
      font-size: clamp(20px, 4.4vw, 24px);
      font-weight: 400;
      box-shadow: 0 2px 10px rgba(0,0,0,0.04);
      white-space: pre-wrap;
      word-break: break-word;
    }
    .cheatword .cheat-label{
      color:#777565;
      font-weight:700; /* fallback if 600 isn't available */
    }
    @supports (font-weight: 600){
      .cheatword .cheat-label{ font-weight:600; }
    }
    .cheatword .cheat-word{ color:#777565; }
    .cheatword strong{
      font-weight: 700;
      color: var(--palette-beige-06);
    }
    .below-actions{
      width: 100%;
      display:flex;
      gap: 10px;
      justify-content: space-between;
      align-items: stretch;
    }
    button{
      appearance:none;
      border: 0;
      background: var(--card);
      color: var(--text);
      border-radius: var(--radius);
      padding: 14px 12px;
      font-size: clamp(14px, 3.2vw, 18px);
      line-height: 1.2;
      cursor:pointer;
      box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.5);
      width: 100%;
      min-height: 56px;
      text-align:center;
    }
    .below-actions button{ flex: 1 1 0; }
    button:active{ transform: translateY(1px); }
    button:disabled{ opacity: 0.55; cursor: default; }
    .status{
      min-height: 20px;
      font-size: 16px;
      text-align:center;
      color: var(--palette-red-07);
      /* font-weight: 600; */
    }
    /* front-only backgrounds */
    body.is-front #frontCheatStrip { background: var(--palette-beige-02); }
    
    /* front-only: meaning option boxes */
    body.is-front #belowActions button { background: var(--palette-beige-01); }
    
    /* back-only: Next Card button */
    body.is-back #belowActions button {
      color: var(--palette-green-07);
      background: var(--palette-green-01);
      font-size: clamp(16px, 3.4vw, 24px);
      font-weight: 700;
    }

    /* --- wrong-answer feedback animations --- */
    @keyframes cardShake {
      0%   { transform: translateX(0); }
      20%  { transform: translateX(-8px); }
      40%  { transform: translateX(8px); }
      60%  { transform: translateX(-6px); }
      80%  { transform: translateX(6px); }
      100% { transform: translateX(0); }
    }
    @keyframes wrongFlash {
      0%   { background: var(--card); box-shadow: 0 2px 10px rgba(0,0,0,0.06); }
      35%  { background: #ffb3b3; box-shadow: 0 2px 10px rgba(0,0,0,0.12); }
      100% { background: var(--card); box-shadow: 0 2px 10px rgba(0,0,0,0.06); }
    }
    
    #flashcard.shake { animation: cardShake 300ms ease; }
    
    @media (prefers-reduced-motion: reduce){
      #flashcard.shake, button.wrong { animation: none; }
}

  </style>
</head>
<body>
  <header>
  <div class="logo">
    <span class="logo-vocab">vocab</span><span class="logo-flash">flash</span>
  </div>
  <div class="tagline">let’s put some vocabulary in your back pocket!</div>
</header>
  <main class="wrap" aria-label="Flashcards">
    <section class="flashcard" id="flashcard" role="group" aria-label="Flashcard"></section>

    <section class="below">
      <div class="cheatword" id="frontCheatStrip" aria-label="Cheat-code word"></div>

      <div class="below-actions" id="belowActions" aria-label="Below-flashcard actions"></div>
      <div class="status" id="status" aria-live="polite"></div>
    </section>
  </main>

  <script>
    "use strict";

  const defaultDeck = [
  // Prefixes
  { type:"prefix", affix:"con-  com-", meaning:"together with", cheat:"construct  >  with structure", hintBold:["with"] },
  { type:"prefix", affix:"in-  im-  ir-  il-", meaning:"not", cheat:"ineffective  >  not effective", hintBold:["not"] },
  { type:"prefix", affix:"ex-", meaning:"outside, away from, no", cheat:"exit  >  go outside", hintBold:["outside"] },
  { type:"prefix", affix:"non-", meaning:"not", cheat:"nonstop  >  not stopping", hintBold:["not"] },
  { type:"prefix", affix:"post-", meaning:"later, after", cheat:"postgame  >  after the game", hintBold:["after"] },
  { type:"prefix", affix:"anti-", meaning:"against, opposite", cheat:"antiwar  >  against war", hintBold:["against"] },
  { type:"prefix", affix:"contra-", meaning:"against, opposite", cheat:'contraband  >  against the "band" (old for "law")', hintBold:["against"] },

  // Suffixes
  { type:"suffix", affix:"-ic", meaning:"like, characteristic of", cheat:"athletic  >  like an athelete", hintBold:["like"] },
  { type:"suffix", affix:"-ive", meaning:"having a quality or tendency", cheat:"creative  >  the quality to create", hintBold:["quality"] },
  { type:"suffix", affix:"-ate", meaning:"office, rank, or location; cause or make", cheat:"graduate  >  rank above/make the grade", hintBold:["rank","make"] },
  { type:"suffix", affix:"-ium", meaning:"relating to status", cheat:"medium  >  middle status", hintBold:["middle"] },
  { type:"suffix", affix:"-ize", meaning:"become, change", cheat:"finalize  >  become final", hintBold:["become"] },
  { type:"suffix", affix:"-or", meaning:"one who does, is from, or has a special characteristic", cheat:"actor  >  one who acts", hintBold:["one who"] },
  { type:"suffix", affix:"-acy", meaning:"state or quality of", cheat:"privacy  >  quality of being private", hintBold:["quality of"] },
  { type:"suffix", affix:"-al", meaning:"act or process of", cheat:"approval  >  act of approving", hintBold:["act of"] },
  { type:"suffix", affix:"-ion  -sion  -tion", meaning:"state of being, quality, action", cheat:"reaction  >  state of reacting", hintBold:["state of"] },
  { type:"suffix", affix:"-ite", meaning:"nature, quality of", cheat:"favorite  >  quality of being favored", hintBold:["quality of"] },
];

    const decks = { default: { mode: "affix", entries: defaultDeck } };
    let activeDeckKey = "default";
    const getActiveDeck = () => decks[activeDeckKey];
    const getActiveEntries = () => getActiveDeck().entries;
    const getActiveMode = () => getActiveDeck().mode;


    const elFlashcard = document.getElementById("flashcard");
    const elFrontCheatStrip = document.getElementById("frontCheatStrip");
    const elBelowActions = document.getElementById("belowActions");
    const elStatus = document.getElementById("status");

    let contentIndex = 0;
    let showingBack = false;

    function escapeHtml(s){
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function parseCheat(cheat){
      const parts = cheat.split(">");
      const word = (parts[0] ?? "").trim();
      const hint = (parts[1] ?? "").trim();
      return { word, hint };
    }

    function affixVariants(affixStr){
      return affixStr
        .split(" ")
        .map(s => s.trim().replace(/^-|-$/g, ""))
        .filter(Boolean)
        .sort((a,b) => b.length - a.length);
    }

    function highlightAffixInCheatWord(word, affixStr, type){
      const safeWord = escapeHtml(word);
      const vars = affixVariants(affixStr);

      // Try best match (longest) at start for prefixes, end for suffixes
      for (const v of vars){
        const vLower = v.toLowerCase();
        const wLower = word.toLowerCase();

        if (type === "prefix" && wLower.startsWith(vLower) && vLower.length > 0){
          const head = safeWord.slice(0, v.length);
          const tail = safeWord.slice(v.length);
          return `<strong>${head}</strong>${tail}`;
        }
        if (type === "suffix" && wLower.endsWith(vLower) && vLower.length > 0){
          const cut = safeWord.length - v.length;
          const head = safeWord.slice(0, cut);
          const tail = safeWord.slice(cut);
          return `${head}<strong>${tail}</strong>`;
        }
      }
      // Fallback: bold whole cheat word
      return `<strong>${safeWord}</strong>`;
    }

    function renderHintWithBold(hint, phrases){
      const raw = String(hint ?? "");
      const list = Array.isArray(phrases)
        ? phrases.map(p => String(p ?? "").trim()).filter(Boolean)
        : [];
    
      if (!list.length) return escapeHtml(raw);
    
      const lower = raw.toLowerCase();
      const ranges = [];
    
      for (const p of list){
        const needle = p.toLowerCase();
        const start = lower.indexOf(needle);
        if (start === -1) continue;
        ranges.push({ start, end: start + needle.length });
      }
    
      if (!ranges.length) return escapeHtml(raw);
    
      ranges.sort((a,b) => a.start - b.start);
    
      // avoid overlaps / nesting
      const nonOverlap = [];
      let lastEnd = -1;
      for (const r of ranges){
        if (r.start < lastEnd) continue;
        nonOverlap.push(r);
        lastEnd = r.end;
      }
    
      let out = "";
      let cursor = 0;
    
      for (const r of nonOverlap){
        out += escapeHtml(raw.slice(cursor, r.start));
        out += "<strong>" + escapeHtml(raw.slice(r.start, r.end)) + "</strong>";
        cursor = r.end;
      }
    
      out += escapeHtml(raw.slice(cursor));
      return out;
    }

        function getAffixMeaningPool(type){
      return Array.from(new Set(
        getActiveEntries()
          .filter(e => e.type === type)
          .map(e => e.meaning)
      ));
    }

    function pickWrongMeanings(correct, type, count){
      const pool = getAffixMeaningPool(type);
      const candidates = pool.filter(m => m !== correct);
      const picks = [];

      // Fisher-Yates-ish picks without duplicates
      while (picks.length < count && candidates.length){
        const j = Math.floor(Math.random() * candidates.length);
        picks.push(candidates[j]);
        candidates.splice(j,1);
      }
      return picks;
    }

    function shuffle(arr){
      for (let i = arr.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function renderFront(){
      showingBack = false;
      elStatus.textContent = "";
      document.body.classList.add("is-front");
      document.body.classList.remove("is-back");

      const mode = getActiveMode();
      const entry = getActiveEntries()[contentIndex];

      if (mode === "qa"){
        elFlashcard.innerHTML = `<p class="meaning">${escapeHtml(entry.q ?? "")}</p>`;

        if (entry.hint){
          elFrontCheatStrip.style.display = "";
          elFrontCheatStrip.textContent = entry.hint;
        } else {
          elFrontCheatStrip.style.display = "none";
        }

        const correct = String(entry.a ?? "");
        const candidates = Array.from(new Set(
          getActiveEntries()
            .map(e => String(e.a ?? ""))
            .filter(a => a && a !== correct)
        ));

        const wrongs = [];
        while (wrongs.length < 2 && candidates.length){
          const j = Math.floor(Math.random() * candidates.length);
          wrongs.push(candidates[j]);
          candidates.splice(j, 1);
        }

        const options = shuffle([correct, ...wrongs]);

        elBelowActions.innerHTML = "";
        for (const opt of options){
          const btn = document.createElement("button");
          btn.type = "button";
          btn.textContent = opt;
          btn.addEventListener("click", () => onChooseMeaning(btn, opt === correct));
          elBelowActions.appendChild(btn);
        }
        return;
      }

      const { word } = parseCheat(entry.cheat);

      elFlashcard.innerHTML = `<div class="front-affix"><strong>${escapeHtml(entry.affix)}</strong></div>`;
      elFrontCheatStrip.style.display = "";
      elFrontCheatStrip.innerHTML = `<span class="cheat-label">cheat code:</span>  <span class="cheat-word">${highlightAffixInCheatWord(word, entry.affix, entry.type)}</span>`;

      const wrongs = pickWrongMeanings(entry.meaning, entry.type, 2);
      const options = shuffle([entry.meaning, ...wrongs]);

      elBelowActions.innerHTML = "";
      for (const opt of options){
        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = opt;
        btn.addEventListener("click", () => onChooseMeaning(btn, opt === entry.meaning));
        elBelowActions.appendChild(btn);
      }
    }

    function renderBack(){
      showingBack = true;
      elStatus.textContent = "";
      document.body.classList.add("is-back");
      document.body.classList.remove("is-front");

      const mode = getActiveMode();
      const entry = getActiveEntries()[contentIndex];

      if (mode === "qa"){
        elFlashcard.innerHTML = `
          <div class="back-affix"><strong>${escapeHtml(entry.q ?? "")}</strong></div>
          <p class="meaning">${escapeHtml(entry.a ?? "")}</p>
        `;
      } else {
        const { word, hint } = parseCheat(entry.cheat);

        const cheatWordHtml = highlightAffixInCheatWord(word, entry.affix, entry.type);
        const hintHtml = renderHintWithBold(hint, entry.hintBold);
        const cheatLineHtml = `<strong>cheat code:</strong>  ${cheatWordHtml}  ≈  ${hintHtml}`;
        elFlashcard.innerHTML = `
          <div class="back-affix"><strong>${escapeHtml(entry.affix)}</strong></div>
          <p class="meaning">${escapeHtml(entry.meaning)}</p>
          <p class="cheatline">${cheatLineHtml}</p>
        `;
      }

      elFrontCheatStrip.style.display = "none";

      elBelowActions.innerHTML = "";
      const nextBtn = document.createElement("button");
      nextBtn.type = "button";
      nextBtn.textContent = "Next Card";
      nextBtn.addEventListener("click", nextCard);
      elBelowActions.appendChild(nextBtn);
    }

    function onChooseMeaning(button, isCorrect){
      if (showingBack) return;
    
      // Clear any lingering text feedback quickly (optional)
      elStatus.textContent = "";
    
      if (isCorrect){
        renderBack();
      } else {
        // Visual-only feedback; allow immediate retry
        button.classList.remove("wrong");
        void button.offsetWidth;           // force reflow so animation can retrigger
        button.classList.add("wrong");
    
        elFlashcard.classList.remove("shake");
        void elFlashcard.offsetWidth;           // force reflow so animation can retrigger
        elFlashcard.classList.add("shake");
    
        // Optional brief text (clears quickly)
        elStatus.textContent = "Select a different answer.";
        setTimeout(() => { elStatus.textContent = ""; }, 1000);
      }
    }

    function nextCard(){
      contentIndex = (contentIndex + 1) % getActiveEntries().length;
      renderFront();
    }

    // Init
    renderFront();
  </script>
</body>
</html>