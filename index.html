<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>vocabflash™</title>
  <link rel="icon" type="image/png" href="vocabflash favicon.png">

  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500&family=Nunito:wght@400;700&family=Archivo:wght@400;600;700&family=Libre+Baskerville:ital@1&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#e9e9e9;
      --card:#ffffff;
      --text:#000000;
      --radius:16px;
      --gap:12px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    .wrap{
      max-width: 720px;
      margin: 0 auto;
      padding: 18px 14px 28px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: var(--gap);
    }
    .card{
      width: min(640px, 100%);
      background: var(--card);
      border-radius: var(--radius);
      padding: 22px 18px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
      text-align:center;
    }
    .front-affix{
      font-weight: 800;
      font-size: clamp(34px, 7.2vw, 56px);
      line-height: 1.1;
      letter-spacing: 0.2px;
      margin: 8px 0;
      word-break: break-word;
    }
    .back-affix{
      font-weight: 800;
      font-size: clamp(28px, 6vw, 42px);
      line-height: 1.15;
      margin: 0 0 10px;
      word-break: break-word;
    }
    .meaning{
      font-size: clamp(18px, 3.8vw, 22px);
      line-height: 1.35;
      margin: 0 0 14px;
    }
    .cheatline{
      font-size: clamp(16px, 3.4vw, 20px);
      line-height: 1.35;
      margin: 0;
      word-break: break-word;
    }
    .below{
      width: min(640px, 100%);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: var(--gap);
    }
    .cheatword{
      width: 100%;
      background: var(--card);
      border-radius: var(--radius);
      padding: 12px 14px;
      text-align:center;
      font-size: clamp(18px, 4vw, 22px);
      font-weight: 700;
      box-shadow: 0 2px 10px rgba(0,0,0,0.04);
      word-break: break-word;
    }
    .choices{
      width: 100%;
      display:flex;
      gap: 10px;
      justify-content: space-between;
      align-items: stretch;
    }
    button{
      appearance:none;
      border: 0;
      background: var(--card);
      color: var(--text);
      border-radius: var(--radius);
      padding: 14px 12px;
      font-size: clamp(14px, 3.2vw, 18px);
      line-height: 1.2;
      cursor:pointer;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
      width: 100%;
      min-height: 56px;
      text-align:center;
    }
    .choices button{ flex: 1 1 0; }
    button:active{ transform: translateY(1px); }
    button:disabled{ opacity: 0.55; cursor: default; }
    .status{
      min-height: 20px;
      font-size: 16px;
      text-align:center;
    }
    /* --- wrong-answer feedback animations --- */
    @keyframes cardShake {
      0%   { transform: translateX(0); }
      20%  { transform: translateX(-8px); }
      40%  { transform: translateX(8px); }
      60%  { transform: translateX(-6px); }
      80%  { transform: translateX(6px); }
      100% { transform: translateX(0); }
    }
    @keyframes wrongFlash {
      0%   { background: var(--card); box-shadow: 0 2px 10px rgba(0,0,0,0.06); }
      35%  { background: #ffb3b3; box-shadow: 0 2px 10px rgba(0,0,0,0.12); }
      100% { background: var(--card); box-shadow: 0 2px 10px rgba(0,0,0,0.06); }
    }
    
    #card.shake { animation: cardShake 420ms ease; }
    button.wrong { animation: wrongFlash 420ms ease; }
    
    @media (prefers-reduced-motion: reduce){
      #card.shake, button.wrong { animation: none; }
}

  </style>
</head>
<body>
  <main class="wrap" aria-label="Affix Flashcards">
    <section class="card" id="card" role="group" aria-label="Flashcard"></section>

    <section class="below">
      <div class="cheatword" id="cheatWordOnly" aria-label="Cheat-code word"></div>

      <div class="choices" id="choices" aria-label="Answer choices"></div>
      <div class="status" id="status" aria-live="polite"></div>
    </section>
  </main>

  <script>
    "use strict";

    const cards = [
      // Prefixes
      { type:"prefix", affix:"con- / com-", meaning:"together with", cheat:"construct > with structure" },
      { type:"prefix", affix:"in- / im- / ir- / il-", meaning:"not", cheat:"ineffective > not effective" },
      { type:"prefix", affix:"ex-", meaning:"outside, away from, no", cheat:"exit > go outside" },
      { type:"prefix", affix:"non-", meaning:"not", cheat:"nonstop > not stopping" },
      { type:"prefix", affix:"post-", meaning:"later, after", cheat:"postgame > after the game" },
      { type:"prefix", affix:"anti-", meaning:"against, opposite", cheat:"antiwar > against war" },
      { type:"prefix", affix:"contra-", meaning:"against, opposite", cheat:'contraband > against the "band" (old word for a "law")' },

      // Suffixes
      { type:"suffix", affix:"-ic", meaning:"like, characteristic of", cheat:"athletic > like an athelete" },
      { type:"suffix", affix:"-ive", meaning:"having a quality or tendency", cheat:"creative > the quality to create" },
      { type:"suffix", affix:"-ate", meaning:"office, rank, or location; cause or make", cheat:"graduate > rank above grade level or make the grade" },
      { type:"suffix", affix:"-ium", meaning:"relating to status", cheat:"medium > middle status" },
      { type:"suffix", affix:"-ize", meaning:"become, change", cheat:"finalize > become final" },
      { type:"suffix", affix:"-or", meaning:"one who does, is from, or has a special characteristic", cheat:"actor > one who acts" },
      { type:"suffix", affix:"-acy", meaning:"state or quality of", cheat:"privacy > quality of being private" },
      { type:"suffix", affix:"-al", meaning:"act or process of", cheat:"approval > act of approving" },
      { type:"suffix", affix:"-ion / -sion / -tion", meaning:"state of being, quality, action", cheat:"reaction > state of reacting" },
      { type:"suffix", affix:"-ite", meaning:"nature, quality of", cheat:"favorite > quality of being favored" },
    ];

    const prefixMeanings = Array.from(new Set(cards.filter(c => c.type === "prefix").map(c => c.meaning)));
    const suffixMeanings = Array.from(new Set(cards.filter(c => c.type === "suffix").map(c => c.meaning)));

    const elCard = document.getElementById("card");
    const elCheatWordOnly = document.getElementById("cheatWordOnly");
    const elChoices = document.getElementById("choices");
    const elStatus = document.getElementById("status");

    let idx = 0;
    let showingBack = false;

    function escapeHtml(s){
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function parseCheat(cheat){
      const parts = cheat.split(">");
      const word = (parts[0] ?? "").trim();
      const hint = (parts[1] ?? "").trim();
      return { word, hint };
    }

    function affixVariants(affixStr, type){
      return affixStr
        .split("/")
        .map(s => s.trim())
        .filter(Boolean)
        .map(a => {
          let v = a;
          if (type === "prefix") {
            v = v.replace(/-$/,"").replace(/^\-/,"");
          } else {
            v = v.replace(/^\-/,"").replace(/-$/,"");
          }
          return v.trim();
        })
        .filter(Boolean)
        .sort((a,b) => b.length - a.length);
    }

    function highlightAffixInCheatWord(word, affixStr, type){
      const safeWord = escapeHtml(word);
      const vars = affixVariants(affixStr, type);

      // Try best match (longest) at start for prefixes, end for suffixes
      for (const v of vars){
        const vLower = v.toLowerCase();
        const wLower = word.toLowerCase();

        if (type === "prefix" && wLower.startsWith(vLower) && vLower.length > 0){
          const head = safeWord.slice(0, v.length);
          const tail = safeWord.slice(v.length);
          return `<strong>${head}</strong>${tail}`;
        }
        if (type === "suffix" && wLower.endsWith(vLower) && vLower.length > 0){
          const cut = safeWord.length - v.length;
          const head = safeWord.slice(0, cut);
          const tail = safeWord.slice(cut);
          return `${head}<strong>${tail}</strong>`;
        }
      }
      // Fallback: bold whole cheat word
      return `<strong>${safeWord}</strong>`;
    }

    function pickWrongMeanings(correct, type, count){
      const pool = (type === "prefix") ? prefixMeanings : suffixMeanings;
      const candidates = pool.filter(m => m !== correct);
      const picks = [];

      // Fisher-Yates-ish picks without duplicates
      while (picks.length < count && candidates.length){
        const j = Math.floor(Math.random() * candidates.length);
        picks.push(candidates[j]);
        candidates.splice(j,1);
      }
      return picks;
    }

    function shuffle(arr){
      for (let i = arr.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function renderFront(){
      showingBack = false;
      elStatus.textContent = "";

      const c = cards[idx];
      const { word } = parseCheat(c.cheat);

      elCard.innerHTML = `<div class="front-affix"><strong>${escapeHtml(c.affix)}</strong></div>`;
      elCheatWordOnly.style.display = "";
      elCheatWordOnly.textContent = word;

      const wrongs = pickWrongMeanings(c.meaning, c.type, 2);
      const options = shuffle([c.meaning, ...wrongs]);

      elChoices.innerHTML = "";
      for (const opt of options){
        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = opt;
        btn.addEventListener("click", () => onChooseMeaning(btn, opt === c.meaning));
        elChoices.appendChild(btn);
      }
    }

    function renderBack(){
      showingBack = true;
      elStatus.textContent = "";

      const c = cards[idx];
      const { word, hint } = parseCheat(c.cheat);

      const cheatWordHtml = highlightAffixInCheatWord(word, c.affix, c.type);
      const cheatLineHtml = `${cheatWordHtml} &gt; ${escapeHtml(hint)}`;

      elCard.innerHTML = `
        <div class="back-affix"><strong>${escapeHtml(c.affix)}</strong></div>
        <p class="meaning">${escapeHtml(c.meaning)}</p>
        <p class="cheatline">${cheatLineHtml}</p>
      `;

      elCheatWordOnly.style.display = "none";

      elChoices.innerHTML = "";
      const nextBtn = document.createElement("button");
      nextBtn.type = "button";
      nextBtn.textContent = "Next Card";
      nextBtn.addEventListener("click", nextCard);
      elChoices.appendChild(nextBtn);
    }

    function onChooseMeaning(button, isCorrect){
      if (showingBack) return;
    
      // Clear any lingering text feedback quickly (optional)
      elStatus.textContent = "";
    
      if (isCorrect){
        renderBack();
      } else {
        // Visual-only feedback; allow immediate retry
        button.classList.remove("wrong");
        void button.offsetWidth;           // force reflow so animation can retrigger
        button.classList.add("wrong");
    
        elCard.classList.remove("shake");
        void elCard.offsetWidth;           // force reflow so animation can retrigger
        elCard.classList.add("shake");
    
        // Optional brief text (clears quickly)
        elStatus.textContent = "Not quite — try again.";
        setTimeout(() => { elStatus.textContent = ""; }, 500);
      }
    }

    function nextCard(){
      idx = (idx + 1) % cards.length;
      renderFront();
    }

    // Init
    renderFront();
  </script>
</body>
</html>