<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>vocabflash™</title>
  <link rel="icon" type="image/png" href="vocabflash favicon.png">

  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500&family=Nunito:wght@400;700&family=Archivo:wght@400;600;700&family=Libre+Baskerville:ital@1&display=swap" rel="stylesheet">

  <style>
    :root{
      --theme-logo-vocab: #777565;   /* change me */
      --theme-logo-flash: #363322;  /* change me */
      --theme-tagline: #8f8d7e;     /* change me */
      --bg:#f4f2e7;
      --card:#ffffff;
      --text:#000000;
      --radius:16px;
      --gap:12px;
    }
    *{ box-sizing:border-box; }
    header {
      text-align: center;
      margin: 1rem 0;
    }
    
    .logo {
      font-family: 'Fredoka', sans-serif;
      font-size: clamp(40px, 10vw, 80px);
      font-weight: 500;
      line-height: 1;
    }
    
    .logo-vocab { color: var(--theme-logo-vocab) !important; forced-color-adjust: none; }
    .logo-flash { color: var(--theme-logo-flash) !important; forced-color-adjust: none; }
    
    .tagline {
      font-family: 'Fredoka', sans-serif;
      font-size: clamp(16px, 3vw, 24px);
      font-weight: 400;
      color: var(--theme-tagline) !important;
      margin-top: 0.25rem;
      forced-color-adjust: none;
}

    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    .wrap{
      max-width: 720px;
      margin: 0 auto;
      padding: 18px 14px 28px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: var(--gap);
    }
    .card{
      width: min(640px, 100%);
      background: var(--card);
      border-radius: var(--radius);
      padding: 22px 18px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
      text-align:center;
    }
    .front-affix{
      font-weight: 800;
      font-size: clamp(34px, 7.2vw, 56px);
      line-height: 1.1;
      letter-spacing: 0.2px;
      margin: 8px 0;
      word-break: break-word;
    }
    .back-affix{
      font-weight: 800;
      font-size: clamp(28px, 6vw, 42px);
      line-height: 1.15;
      margin: 0 0 10px;
      word-break: break-word;
    }
    .meaning{
      font-size: clamp(18px, 3.8vw, 22px);
      line-height: 1.35;
      margin: 6px 0 18px;
    }
    .cheatline{
      font-size: clamp(16px, 3.4vw, 20px);
      line-height: 1.35;
      margin: 0;
      word-break: break-word;
    }
    .below{
      width: min(640px, 100%);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: var(--gap);
    }
    .cheatword{
      width: 100%;
      background: var(--card);
      border-radius: var(--radius);
      padding: 12px 14px;
      text-align:center;
      font-size: clamp(20px, 4.4vw, 24px);
      font-weight: 400;
      box-shadow: 0 2px 10px rgba(0,0,0,0.04);
      word-break: break-word;
    }
    .cheatword .cheat-label{
      color:#777565;
      font-weight:700; /* fallback if 600 isn't available */
    }
    @supports (font-weight: 600){
      .cheatword .cheat-label{ font-weight:600; }
    }
    .cheatword .cheat-word{ color:#777565; }
    .cheatword strong{ font-weight: 700; }
    .choices{
      width: 100%;
      display:flex;
      gap: 10px;
      justify-content: space-between;
      align-items: stretch;
    }
    button{
      appearance:none;
      border: 0;
      background: var(--card);
      color: var(--text);
      border-radius: var(--radius);
      padding: 14px 12px;
      font-size: clamp(14px, 3.2vw, 18px);
      line-height: 1.2;
      cursor:pointer;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
      width: 100%;
      min-height: 56px;
      text-align:center;
    }
    .choices button{ flex: 1 1 0; }
    button:active{ transform: translateY(1px); }
    button:disabled{ opacity: 0.55; cursor: default; }
    .status{
      min-height: 20px;
      font-size: 16px;
      text-align:center;
    }
    /* front-only backgrounds */
    body.is-front #cheatWordOnly { background: #c0beb1; }
    
    /* front-only: meaning option boxes */
    body.is-front #choices button { background: #dad8cc; }
    
    /* back-only: Next Card button */
    body.is-back #choices button { background: #dad8cc; }

    /* --- wrong-answer feedback animations --- */
    @keyframes cardShake {
      0%   { transform: translateX(0); }
      20%  { transform: translateX(-8px); }
      40%  { transform: translateX(8px); }
      60%  { transform: translateX(-6px); }
      80%  { transform: translateX(6px); }
      100% { transform: translateX(0); }
    }
    @keyframes wrongFlash {
      0%   { background: var(--card); box-shadow: 0 2px 10px rgba(0,0,0,0.06); }
      35%  { background: #ffb3b3; box-shadow: 0 2px 10px rgba(0,0,0,0.12); }
      100% { background: var(--card); box-shadow: 0 2px 10px rgba(0,0,0,0.06); }
    }
    
    #card.shake { animation: cardShake 420ms ease; }
    button.wrong { animation: wrongFlash 420ms ease; }
    
    @media (prefers-reduced-motion: reduce){
      #card.shake, button.wrong { animation: none; }
}

  </style>
</head>
<body>
  <header>
  <div class="logo">
    <span class="logo-vocab">vocab</span><span class="logo-flash">flash</span>
  </div>
  <div class="tagline">let’s put some vocabulary in your back pocket!</div>
</header>
  <main class="wrap" aria-label="Affix Flashcards">
    <section class="card" id="card" role="group" aria-label="Flashcard"></section>

    <section class="below">
      <div class="cheatword" id="cheatWordOnly" aria-label="Cheat-code word"></div>

      <div class="choices" id="choices" aria-label="Answer choices"></div>
      <div class="status" id="status" aria-live="polite"></div>
    </section>
  </main>

  <script>
    "use strict";

    const cards = [
  // Prefixes
  { type:"prefix", affix:"con- / com-", meaning:"together with", cheat:"construct > with structure", hintBold:["with"] },
  { type:"prefix", affix:"in- / im- / ir- / il-", meaning:"not", cheat:"ineffective > not effective", hintBold:["not"] },
  { type:"prefix", affix:"ex-", meaning:"outside, away from, no", cheat:"exit > go outside", hintBold:["outside"] },
  { type:"prefix", affix:"non-", meaning:"not", cheat:"nonstop > not stopping", hintBold:["not"] },
  { type:"prefix", affix:"post-", meaning:"later, after", cheat:"postgame > after the game", hintBold:["after"] },
  { type:"prefix", affix:"anti-", meaning:"against, opposite", cheat:"antiwar > against war", hintBold:["against"] },
  { type:"prefix", affix:"contra-", meaning:"against, opposite", cheat:'contraband > against the "band" (old word for a "law")', hintBold:["against"] },

  // Suffixes
  { type:"suffix", affix:"-ic", meaning:"like, characteristic of", cheat:"athletic > like an athelete", hintBold:["like"] },
  { type:"suffix", affix:"-ive", meaning:"having a quality or tendency", cheat:"creative > the quality to create", hintBold:["quality"] },
  { type:"suffix", affix:"-ate", meaning:"office, rank, or location; cause or make", cheat:"graduate > rank above grade level or make the grade", hintBold:["rank","make"] },
  { type:"suffix", affix:"-ium", meaning:"relating to status", cheat:"medium > middle status", hintBold:["middle"] },
  { type:"suffix", affix:"-ize", meaning:"become, change", cheat:"finalize > become final", hintBold:["become"] },
  { type:"suffix", affix:"-or", meaning:"one who does, is from, or has a special characteristic", cheat:"actor > one who acts", hintBold:["one who"] },
  { type:"suffix", affix:"-acy", meaning:"state or quality of", cheat:"privacy > quality of being private", hintBold:["quality of"] },
  { type:"suffix", affix:"-al", meaning:"act or process of", cheat:"approval > act of approving", hintBold:["act of"] },
  { type:"suffix", affix:"-ion / -sion / -tion", meaning:"state of being, quality, action", cheat:"reaction > state of reacting", hintBold:["state of"] },
  { type:"suffix", affix:"-ite", meaning:"nature, quality of", cheat:"favorite > quality of being favored", hintBold:["quality of"] },
];

    const prefixMeanings = Array.from(new Set(cards.filter(c => c.type === "prefix").map(c => c.meaning)));
    const suffixMeanings = Array.from(new Set(cards.filter(c => c.type === "suffix").map(c => c.meaning)));

    const elCard = document.getElementById("card");
    const elCheatWordOnly = document.getElementById("cheatWordOnly");
    const elChoices = document.getElementById("choices");
    const elStatus = document.getElementById("status");

    let idx = 0;
    let showingBack = false;

    function escapeHtml(s){
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function parseCheat(cheat){
      const parts = cheat.split(">");
      const word = (parts[0] ?? "").trim();
      const hint = (parts[1] ?? "").trim();
      return { word, hint };
    }

    function affixVariants(affixStr, type){
      return affixStr
        .split("/")
        .map(s => s.trim())
        .filter(Boolean)
        .map(a => {
          let v = a;
          if (type === "prefix") {
            v = v.replace(/-$/,"").replace(/^\-/,"");
          } else {
            v = v.replace(/^\-/,"").replace(/-$/,"");
          }
          return v.trim();
        })
        .filter(Boolean)
        .sort((a,b) => b.length - a.length);
    }

    function formatAffixDisplay(affixStr){
      return affixStr
        .split("/")
        .map(s => s.trim())
        .filter(Boolean)
        .join(" ")
        .replace(/\s+/g, " ");
    }

    function highlightAffixInCheatWord(word, affixStr, type){
      const safeWord = escapeHtml(word);
      const vars = affixVariants(affixStr, type);

      // Try best match (longest) at start for prefixes, end for suffixes
      for (const v of vars){
        const vLower = v.toLowerCase();
        const wLower = word.toLowerCase();

        if (type === "prefix" && wLower.startsWith(vLower) && vLower.length > 0){
          const head = safeWord.slice(0, v.length);
          const tail = safeWord.slice(v.length);
          return `<strong>${head}</strong>${tail}`;
        }
        if (type === "suffix" && wLower.endsWith(vLower) && vLower.length > 0){
          const cut = safeWord.length - v.length;
          const head = safeWord.slice(0, cut);
          const tail = safeWord.slice(cut);
          return `${head}<strong>${tail}</strong>`;
        }
      }
      // Fallback: bold whole cheat word
      return `<strong>${safeWord}</strong>`;
    }

    function renderHintWithBold(hint, phrases){
      const raw = String(hint ?? "");
      const list = Array.isArray(phrases)
        ? phrases.map(p => String(p ?? "").trim()).filter(Boolean)
        : [];
    
      if (!list.length) return escapeHtml(raw);
    
      const lower = raw.toLowerCase();
      const ranges = [];
    
      for (const p of list){
        const needle = p.toLowerCase();
        const start = lower.indexOf(needle);
        if (start === -1) continue;
        ranges.push({ start, end: start + needle.length });
      }
    
      if (!ranges.length) return escapeHtml(raw);
    
      ranges.sort((a,b) => a.start - b.start);
    
      // avoid overlaps / nesting
      const nonOverlap = [];
      let lastEnd = -1;
      for (const r of ranges){
        if (r.start < lastEnd) continue;
        nonOverlap.push(r);
        lastEnd = r.end;
      }
    
      let out = "";
      let cursor = 0;
    
      for (const r of nonOverlap){
        out += escapeHtml(raw.slice(cursor, r.start));
        out += "<strong>" + escapeHtml(raw.slice(r.start, r.end)) + "</strong>";
        cursor = r.end;
      }
    
      out += escapeHtml(raw.slice(cursor));
      return out;
    }

    function pickWrongMeanings(correct, type, count){
      const pool = (type === "prefix") ? prefixMeanings : suffixMeanings;
      const candidates = pool.filter(m => m !== correct);
      const picks = [];

      // Fisher-Yates-ish picks without duplicates
      while (picks.length < count && candidates.length){
        const j = Math.floor(Math.random() * candidates.length);
        picks.push(candidates[j]);
        candidates.splice(j,1);
      }
      return picks;
    }

    function shuffle(arr){
      for (let i = arr.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function renderFront(){
      showingBack = false;
      elStatus.textContent = "";
      document.body.classList.add("is-front");
      document.body.classList.remove("is-back");

      const c = cards[idx];
      const { word } = parseCheat(c.cheat);

    elCard.innerHTML = `<div class="front-affix"><strong>${escapeHtml(formatAffixDisplay(c.affix))}</strong></div>`;
    elCheatWordOnly.style.display = "";
elCheatWordOnly.innerHTML = `<span class="cheat-label">cheat code:</span>&nbsp;&nbsp;<span class="cheat-word">${highlightAffixInCheatWord(word, c.affix, c.type)}</span>`;

      const wrongs = pickWrongMeanings(c.meaning, c.type, 2);
      const options = shuffle([c.meaning, ...wrongs]);

      elChoices.innerHTML = "";
      for (const opt of options){
        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = opt;
        btn.addEventListener("click", () => onChooseMeaning(btn, opt === c.meaning));
        elChoices.appendChild(btn);
      }
    }

    function renderBack(){
      showingBack = true;
      elStatus.textContent = "";
      document.body.classList.add("is-back");
      document.body.classList.remove("is-front");

      const c = cards[idx];
      const { word, hint } = parseCheat(c.cheat);

      const cheatWordHtml = highlightAffixInCheatWord(word, c.affix, c.type);
      const hintHtml = renderHintWithBold(hint, c.hintBold);
      const cheatLineHtml = `${cheatWordHtml}&nbsp;&nbsp;&gt;&nbsp;&nbsp;${hintHtml}`;

      elCard.innerHTML = `
        <div class="back-affix"><strong>${escapeHtml(formatAffixDisplay(c.affix))}</strong></div>
        <p class="meaning">${escapeHtml(c.meaning)}</p>
        <p class="cheatline">${cheatLineHtml}</p>
      `;

      elCheatWordOnly.style.display = "none";

      elChoices.innerHTML = "";
      const nextBtn = document.createElement("button");
      nextBtn.type = "button";
      nextBtn.textContent = "Next Card";
      nextBtn.addEventListener("click", nextCard);
      elChoices.appendChild(nextBtn);
    }

    function onChooseMeaning(button, isCorrect){
      if (showingBack) return;
    
      // Clear any lingering text feedback quickly (optional)
      elStatus.textContent = "";
    
      if (isCorrect){
        renderBack();
      } else {
        // Visual-only feedback; allow immediate retry
        button.classList.remove("wrong");
        void button.offsetWidth;           // force reflow so animation can retrigger
        button.classList.add("wrong");
    
        elCard.classList.remove("shake");
        void elCard.offsetWidth;           // force reflow so animation can retrigger
        elCard.classList.add("shake");
    
        // Optional brief text (clears quickly)
        elStatus.textContent = "Not quite — try again.";
        setTimeout(() => { elStatus.textContent = ""; }, 500);
      }
    }

    function nextCard(){
      idx = (idx + 1) % cards.length;
      renderFront();
    }

    // Init
    renderFront();
  </script>
</body>
</html>